{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>NeSI ephemeral training environments, running on Flexi HPC, deployed using Terraform and Ansible and using Open OnDemand as the user interface.</p>"},{"location":"#architecture","title":"Architecture","text":"<p>The training environment consists of multiple VMs:</p> <ul> <li>web node VM<ul> <li>running the Open OnDemand web node software</li> <li>LDAP client</li> </ul> </li> <li>services node VM<ul> <li>LDAP server</li> <li>Keycloak</li> <li>NFS server sharing training user home directories</li> </ul> </li> <li>kubernetes cluster<ul> <li>the users' Open OnDemand apps run here (JupyterLab, RStudio, etc.)</li> <li>each node in the cluster is an LDAP client</li> </ul> </li> </ul>"},{"location":"#apps","title":"Apps","text":"<p>Open OnDemand interactive applications, such as JupyterLab and RStudio, are used for the training courses. More information about apps can be found here.</p>"},{"location":"#user-accounts","title":"User accounts","text":"<p>Within the training environment we create two different types of user accounts, training users and trainer users, with randomly generated passwords.</p> <ul> <li>training accounts<ul> <li>isolated accounts that can only access their own home directory</li> </ul> </li> <li>trainer accounts<ul> <li>have read-only access to training user home directories, to monitor progress and assist</li> <li>can use the browser based terminal from the OnDemand web interface</li> </ul> </li> </ul>"},{"location":"deployment/","title":"Deployment","text":"<p>TODO:</p> <ul> <li>process, configuring (num users, etc)</li> </ul>"},{"location":"notes-for-trainers/","title":"Notes for trainers","text":""},{"location":"notes-for-trainers/#viewing-training-users-files","title":"Viewing training user's files","text":"<p>All trainer users should have read access on all training users home directories to help with debugging issues, checking progress, etc. The paths to the home directories will look like:</p> <pre><code>/home/shared/training1\n/home/shared/training2\n...\n</code></pre>"},{"location":"notes-for-trainers/#recommended-browsers","title":"Recommended browsers","text":"<p>Following upstream Open OnDemand documentation we highly recommend the use of Chrome, Firefox or Edge.</p> <p>Other browsers and extensions (ad blockers, etc) could cause issues. For example, we have observed problems with the DuckDuckGo browser, which blocked the password from being passed transparently to JupyterLab, causing an \"Invalid credentials\" error.</p> <p></p>"},{"location":"notes-for-trainers/#session-limits","title":"Session limits","text":"<p>Each user (both trainer and training users) are limited to one running session (app) at a time, to ensure there are enough resources for everyone to run something. To restart an app, or stop an app so that you can start another one, you should:</p> <ul> <li>browse to the \"My Interactive Sessions\" tab</li> <li>click \"Delete\" on the running session</li> <li>important: wait for approx one minute for the underlying pod to get properly deleted by the kubernetes cluster (otherwise you will get an error at the next step)</li> <li>launch the new app</li> </ul> <p>If you try to launch the new app too soon after deleting, or while a session is already running, you will get a Failed to submit session error.</p>"},{"location":"notes-for-trainers/#browser-based-terminal-app","title":"Browser based terminal app","text":"<p>The browser based terminal in the OnDemand web interface runs on the webnode and can be used to monitor progress and assist training users from outside the apps. These terminal sessions run on the OnDemand web node and do not have any resource restrictions, so nothing resource intensive should be run there. Only trainer users can use this feature; if training users try to use it they will get an error.</p>"},{"location":"notes-for-trainers/#list-running-sessions","title":"List running sessions","text":"<p>You can list running sessions, for example to see how many training users have successfully started a session, via the browser based terminal app using the following commands:</p> <ul> <li><code>nesi-get-pods</code></li> <li><code>nesi-get-pods-wide</code></li> </ul> <p>These will list all pods on the kubernetes cluster. You could filter them by looking just for training user pods and just those that are currently running, for example:</p> <pre><code>nesi-get-pods | grep user-training | grep Running\n</code></pre> <p>will show just training user pods that are running, while</p> <pre><code>nesi-get-pods | grep user-\n</code></pre> <p>will show both training and trainer pods, including those in all states (not just running).</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Some common errors are listed on this page.</p>"},{"location":"troubleshooting/#failed-to-submit-session","title":"Failed to submit session","text":"<p>Seeing an error similar to the above image is usually caused by trying to start a new session when one is already running.</p> <p>Follow the steps here to stop your existing session before starting the new one.</p>"},{"location":"apps/","title":"Apps","text":""},{"location":"apps/#overview","title":"Overview","text":"<p>Open OnDemand app development is described in detail in their documentation.</p> <p>In particular, the training environment uses a kubernetes cluster for running the apps, so the apps are developed similarly to the kubernetes examples on the Open OnDemand website:</p> <ul> <li>Add a Jupyter App on a Kubernetes Cluster</li> <li>Add a Jupyter App on a Kubernetes Cluster that behaves like HPC compute</li> </ul> <p>On the following pages are some examples of apps that have been developed to run on the training environment.</p>"},{"location":"apps/#key-points","title":"Key points","text":"<ul> <li>Apps are created as docker images</li> <li>Apps are set up as LDAP clients so training and trainer users are identified correctly within the container<ul> <li>the nslcd socket from the kubernetes worker node is bound into the container at the correct location</li> <li>the /etc/nsswitch.conf file from the kubernetes worked node is bound into the container</li> <li>LDAP client packages are installed inside the container (nslcd, etc)</li> </ul> </li> <li>All home directories are bound into the container (so trainer users can access training users' homes from within the apps if needed)</li> </ul>"},{"location":"apps/#general-structure-of-open-ondemand-apps","title":"General structure of Open OnDemand apps","text":"<p>TODO</p>"},{"location":"apps/example-conda-jupyterlab-ml101/","title":"Example: conda based JupyterLab app for ML101","text":"<p>TODO...</p>"},{"location":"apps/example-rstudio-rna-seq/","title":"RStudio based app for RNA-Seq","text":""},{"location":"apps/example-rstudio-rna-seq/#overview","title":"Overview","text":"<p>App developed for the RNA-Seq workshop using RStudio.</p>"},{"location":"apps/example-venv-jupyterlab-ml102/","title":"Example: venv based JupyterLab app for ML102","text":"<p>TODO...</p>"},{"location":"tutorials/jupyterlab-app-for-intermediate-shell-for-bioinformatics/","title":"JupyterLab app for Intermediate Shell for Bioinformatics","text":"<p>This tutorial will show how to create a JupyterLab based app for teaching intermediate shell for bioinformatics.</p> <p>The GitHub repo for the app that this tutorial is based on can be found here.</p> <p>The app has a standard structure for a Kubernetes based Open OnDemand app and the related upstream documentation may be useful:</p> <ul> <li>Add a Jupyter App on a Kubernetes cluster</li> <li>Add a Jupyter App on a Kubernetes cluster that behaves like HPC compute</li> </ul> <p>In this tutorial we will go through the different files in the above repo and how we have customised them for this training app.</p> <p>Files with .erb extension</p> <p>Files with a .erb extension below are run through the Embedded Ruby template engine. If you don't need this you can remove the .erb extension, or add it to files where you need it.</p>"},{"location":"tutorials/jupyterlab-app-for-intermediate-shell-for-bioinformatics/#layout","title":"Layout","text":"<p>The layout of the app looks like:</p> <pre><code>intermediate-shell-app\n\u251c\u2500\u2500 docker\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 Dockerfile\n\u251c\u2500\u2500 form.yml\n\u251c\u2500\u2500 icon.png\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 manifest.yml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 submit.yml.erb\n\u251c\u2500\u2500 template\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 script.sh.erb\n\u2514\u2500\u2500 view.html.erb\n</code></pre> <p>In the following sections we go into more detail about each file.</p>"},{"location":"tutorials/jupyterlab-app-for-intermediate-shell-for-bioinformatics/#formyml","title":"form.yml","text":"<p>In the form.yml file we set the name of the cluster that this app should belong to. In our case the cluster is hard-coded in our Open OnDemand deployment to be called <code>my-k8s-cluster</code> so we should never need to change this:</p> <pre><code>cluster: \"my-k8s-cluster\"\n</code></pre> <p>The form section defines some parameters that can be set on the launcher form and used by us to configure the app at run time. Here we define three parameters:</p> <pre><code>form:\n  - cpu\n  - memory\n  - wall_time\n</code></pre> <p>In the attributes section we define how the above parameters should appear to the user on the launcher form. We hard-code the CPU and memory requirements to 2 CPUs and 4 GB RAM, so these options won't appear on the form but they will be available for us to use later (once the user has clicked the launch button):</p> <pre><code>attributes:\n  cpu: 2\n  memory: 4\n</code></pre> <p>The walltime option is configurable by the user (although not enforced by us at the time of writing...). We allow the user to choose a value between 4 and 12 hours and the form will be pre-populated with a default value of 8 hours:</p> <pre><code>attributes:\n  cpu: 2\n  memory: 4\n  wall_time:\n    widget: number_field\n    label: \"Hours\"\n    min: 4\n    max: 12\n    value: 8\n</code></pre> <p>Different widgets are available. See also the upstream documentation.</p> View complete form.yml <pre><code>---\ncluster: \"my-k8s-cluster\"\n\nform:\n  - cpu\n  - memory\n  - wall_time\n\nattributes:\n  cpu: 2\n  memory: 4\n  wall_time:\n    widget: number_field\n    label: \"Hours\"\n    min: 4\n    max: 12\n    value: 8\n</code></pre>"},{"location":"tutorials/jupyterlab-app-for-intermediate-shell-for-bioinformatics/#manifestyml","title":"manifest.yml","text":"<p>The manifest.yml files defines how the app shows up in the user interface, e.g. what name it will have</p> <pre><code>name: Intermediate shell for bioinformatics\n</code></pre> <p>For the training environment we don't need to change the following:</p> <pre><code>category: Interactive Apps\nsubcategory: Servers\nrole: batch_connect\n</code></pre> <p>but can edit the description to be something relevant:</p> <pre><code>description: |\n  This app will launch a Jupyter Lab server for the intermediate shell for bioinformatics workshop\n</code></pre> View complete manifest.yml <pre><code>---\nname: Intermediate shell for bioinformatics\ncategory: Interactive Apps\nsubcategory: Servers\nrole: batch_connect\ndescription: |\n  This app will launch a Jupyter Lab server for the intermediate shell for bioinformatics workshop\n</code></pre>"},{"location":"tutorials/jupyterlab-app-for-intermediate-shell-for-bioinformatics/#submitymlerb","title":"submit.yml.erb","text":""},{"location":"tutorials/jupyterlab-app-for-intermediate-shell-for-bioinformatics/#viewhtmlerb","title":"view.html.erb","text":"<p>The view.html.erb file contains the html form with a button that the users clicks to connect to the app once it has started (this is the button that shows up in the Open OnDemand user interface). Most of this file should not need to change unless you switch to using a different underlying web application, i.e. RStudio vs JupyterLab.</p> <p>When the form is submitted it redirects the user to the link specified in the action. Here the <code>&lt;%= host %&gt;</code> and <code>&lt;%= port %&gt;</code> are ruby variables that get inserted when the view.html.erb file is run through the ERB template engine to generate view.html.</p> <pre><code>&lt;form action=\"/node/&lt;%= host %&gt;/&lt;%= port %&gt;/login\" method=\"post\" target=\"_blank\"&gt;\n</code></pre> <p>For a JupyterLab app we need to pass through the password that was set during initialisation of the app, otherwise the user would have to manually input it. This is achieved using a hidden input on the form and the <code>&lt;%= password %&gt;</code> ruby variable:</p> <pre><code>&lt;form action=\"/node/&lt;%= host %&gt;/&lt;%= port %&gt;/login\" method=\"post\" target=\"_blank\"&gt;\n  &lt;input type=\"hidden\" name=\"password\" value=\"&lt;%= password %&gt;\"&gt;\n</code></pre> <p>The only line we may want to change in this file is the text that will be shown on the button:</p> <pre><code>&lt;form action=\"/node/&lt;%= host %&gt;/&lt;%= port %&gt;/login\" method=\"post\" target=\"_blank\"&gt;\n  &lt;input type=\"hidden\" name=\"password\" value=\"&lt;%= password %&gt;\"&gt;\n  &lt;button class=\"btn btn-primary\" type=\"submit\"&gt;\n    &lt;i class=\"fa fa-registered\"&gt;&lt;/i&gt; Connect to Intermediate Shell app\n  &lt;/button&gt;\n&lt;/form&gt;\n</code></pre>"},{"location":"tutorials/jupyterlab-app-for-intermediate-shell-for-bioinformatics/#templatescriptsherb","title":"template/script.sh.erb","text":""},{"location":"tutorials/jupyterlab-app-for-intermediate-shell-for-bioinformatics/#dockerdockerfile","title":"docker/Dockerfile","text":""}]}